# Interview question

Save base interview question

# JS/TS

---

> Расскажи про асинхроность в JS, "микро таски", "макро таски".

## Асинхронность в JavaScript: микротаски и макротаски

Асинхронность в JavaScript — это возможность выполнять задачи, не блокируя основной поток выполнения. Она лежит в основе отзывчивых веб-приложений, позволяя браузеру «не зависать» во время работы с долгими операциями (например, запросы к серверу или ожидание пользовательских действий).

### Как работает асинхронность

JavaScript — язык с _однопоточным_ исполнением. Это означает, что код выполняется построчно. Однако для «неблокирующих» задач используется **Event Loop** (цикл событий), который управляет очередями задач и позволяет запускать асинхронный код тогда, когда это безопасно.

### Основные понятия

#### 1. Call Stack (Стек вызовов)

- Основной стек, где выполняется синхронный JS-код.

#### 2. Event Loop (Цикл событий)

- Постоянно следит за стеком вызовов и очередями задач.
- Когда стек пуст, event loop начинает обрабатывать задачи из очереди.

#### 3. Очереди задач

В JS их две основных:

- **Макротаски (Macrotasks/Task Queue)**
- **Микротаски (Microtasks/Microtask Queue)**

### Макротаски vs. Микротаски

#### Макротаски (Task Queue / Macrotasks)

- Сюда попадают колбэки от:
  - `setTimeout`, `setInterval`
  - Обработчики событий (`click`, `load`, и т.п.)
  - I/O-операции (например, чтение файлов, сетевые запросы)
- Когда call stack пуст, event loop берёт первую макротаску и начинает её исполнять.
- После выполнения макротаски (и связанного синхронного кода), **event loop ОБЯЗАТЕЛЬНО выполнит все микротаски** перед тем, как перейти к следующей макротаске.

#### Микротаски (Microtask Queue)

- Сюда попадают:
  - Колбэки `.then`/`.catch`/`.finally` у Promise
  - `queueMicrotask`
  - `MutationObserver`
- После каждого макротаска **event loop полностью очищает очередь микротасков** (даже если в процессе возникнут ещё микротаски).
- Микротаски имеют более высокий приоритет, чем макротаски.

### Порядок выполнения

1. Выполняется весь синхронный код (call stack).
2. Когда стек пуст, event loop берёт первую макротаску из очереди и исполняет её.
3. После завершения макротаски event loop последовательно выполняет все микротаски.
4. Цикл повторяется: снова берётся следующая макротаска, затем микротаски и т.д.

#### Иллюстративный пример

```js
console.log("Start");

setTimeout(() => {
  console.log("Macrotask");
}, 0);

Promise.resolve().then(() => {
  console.log("Microtask");
});

console.log("End");
```

**Результат в консоли:**

```
Start
End
Microtask
Macrotask
```

- Все синхронные сообщения (`Start`, `End`) печатаются сразу.
- Затем выполняется микротаск (Promise).
- И только после этого исполняется макротаск (`setTimeout`).

### Почему это важно?

- Понимание очередности выполнения микротасков и макротасков критично для правильной работы с Promise, таймерами и обработкой событий.
- Ошибки в понимании этой очередности могут приводить к багам (например, неожидаемому порядку выполнения кода).

### Сводная таблица

| Тип        | Примеры                                        | Когда исполняется                           | Приоритет |
| ---------- | ---------------------------------------------- | ------------------------------------------- | --------- |
| Макротаски | setTimeout, setInterval, I/O, события DOM      | После выполнения микротасков                | Ниже      |
| Микротаски | Promise.then, queueMicrotask, MutationObserver | Всегда после каждой макротаски до следующей | Выше      |

### Кратко

- **Асинхронность** в JS реализуется через event loop.
- Все задачи делятся на **макротаски** и **микротаски**.
- **Микротаски** всегда выполняются раньше каждой следующей макротаски.
- Таким образом, Promise и другие микротаски «всегда успевают» завершиться до перехода к новой фазе массива задач.

Асинхронная модель и очередь микрозадач/макрозадач делают JavaScript мощным инструментом для создания быстрых и отзывчивых приложений, несмотря на его однопоточную природу.

---

> расскажи про дженерики в TS

**Дженерики** (generics, обобщения) в TypeScript — это механизм, позволяющий создавать универсальные функции, интерфейсы и классы, которые работают с разными типами данных, сохраняя при этом строгую типовую безопасность. Дженерики позволяют избежать дублирования кода и делают функции и структуры данных гибче.

### Основная идея

Дженерики позволяют создавать компоненты (функции, классы, интерфейсы), в которых тип данных не фиксирован, а задаётся позднее — при использовании этого компонента. Это выглядит так:

```typescript
function identity<T>(arg: T): T {
  return arg;
}

let output1 = identity<string>("myString"); // output1: string
let output2 = identity<number>(100); // output2: number
```

Здесь `T` — параметр типа (generic parameter), который будет подставлен вызовом функции.

### Где применяются дженерики

- **Функции**  
  Позволяют создавать функции, работающие с разными типами:
  ```typescript
  function reverse<T>(items: T[]): T[] {
    return items.reverse();
  }
  ```
- **Классы**  
  Позволяют создать универсальные структуры данных:
  ```typescript
  class Queue<T> {
    private data: T[] = [];
    push(item: T) {
      this.data.push(item);
    }
    pop(): T | undefined {
      return this.data.shift();
    }
  }
  let numberQueue = new Queue<number>();
  let stringQueue = new Queue<string>();
  ```
- **Интерфейсы** и **типы**
  ```typescript
  interface Pair<T, U> {
    first: T;
    second: U;
  }
  const pair: Pair<number, string> = { first: 1, second: "one" };
  ```

---

### Ограничения дженериков (Generic Constraints)

Если нужно ограничить, какие типы можно подставлять в дженерик, используют `extends`:

```typescript
interface Lengthwise {
  length: number;
}

function getLength<T extends Lengthwise>(arg: T): number {
  return arg.length;
}
```

Теперь функция принимает только те типы, у которых есть свойство `length` — строка, массив и т.д.

### Примеры полезных дженериков

#### Доступ к свойству объекта:

```typescript
function getPropertyValue<Obj, Key extends keyof Obj>(
  obj: Obj,
  key: Key
): Obj[Key] {
  return obj[key];
}
// getPropertyValue({a: 2, b: 3}, 'a'); // ok
// getPropertyValue({a: 2, b: 3}, 'c'); // ошибка
```

Здесь `Key` ограничен возможными ключами объекта `Obj`.

### Автоматический вывод типов

В большинстве случаев TypeScript может сам определить тип дженерика на основании переданных аргументов:

```typescript
function foo<T>(value: T): T[] {
  return [value];
}
const arr = foo(1); // arr: number[]
```

---

### Практическая польза дженериков

- **Гибкость и повторное использование**: Один и тот же компонент/функция работает с любыми типами, экономя время и уменьшает ошибочность.
- **Типовая безопасность**: Нельзя случайно передать данные не того типа. TypeScript всё проверит на этапе компиляции.
- **Замена any**: Дженерики позволяют не использовать тип any, сохраняя контроль типов.

### Итоги

- **Дженерики** позволяют создавать универсальные структуры, работающие с разными типами данных, избегая дублирования кода и сохраняя строгую типизацию.
- Они поддерживаются в функциях, классах, интерфейсах, типаx и могут иметь ограничения.
- Используйте их, если ваш компонент должен корректно работать с данными разного типа, но важно сохранить контроль за ними на этапе компиляции.

---

> что такое батчинг в рамках JS/TS

**Батчинг** (batching) в контексте **JavaScript/TypeScript** и современных UI-фреймворков (чаще всего React) — это процесс, при котором _несколько обновлений состояния или других операций собираются в «пакет» (batch) и выполняются вместе_, чтобы минимизировать количество перерисовок (render) компонента и повысить производительность приложения.

### Ключевые аспекты батчинга:

- **Суть:** Когда происходит серия изменений состояния (например, несколько вызовов `setState` или аналогов), они _не приводят к каждой отдельной перерисовке_. Вместо этого такие изменения объединяются, и UI обновляется только один раз после выполнения всех операций.

- **Автоматический батчинг (React 18+):** Начиная с React 18, любые изменения состояния, в том числе из асинхронных мест (промисы, таймеры), группируются автоматически. До этого батчинг происходил только внутри обработчиков событий React, и для прочих случаев иногда требовалось использовать специальные подходы, например, функцию `batch` из `react-redux` или `unstable_batchedUpdates()`.

- **Цель:** Повысить производительность за счёт:
  - Снижения числа рендеров.
  - Меньшего количества операций с DOM.
  - Сохранения целостности состояния UI.

### Пример на JS/TS (React):

```tsx
function Example() {
  const [count, setCount] = useState(0);
  const [message, setMessage] = useState("");

  const updateState = () => {
    setCount((c) => c + 1);
    setMessage("Значение обновлено");
  };

  // Оба изменения состояния попадут в один батч — только одна перерисовка!
  return (
    <div>
      <p>{count}</p>
      <p>{message}</p>
      <button onClick={updateState}>Обновить</button>
    </div>
  );
}
```

В этом примере оба вызова `setState` попадут в один батч, и UI перерисуется один раз.

### Батчинг вне React

В общем смысле (и вне React) термин «батчинг» в JS/TS также означает группировку каких-либо однотипных задач (запросов, операций, вызовов) для их _совместного выполнения_, оптимизации обработки или уменьшения overhead (например, пакетная отправка данных на сервер, отрисовка батчами в WebGL и др.).

### Ограничения и детали

- Конкретная реализация батчинга зависит от используемого фреймворка и контекста применения.
- В классическом «чистом» JS/TS (без React) батчинг — это скорее архитектурный приём, чем встроенная функциональность.

**Вывод:**  
**Батчинг** — это пакетная обработка операций обновления (чаще всего состояния), позволяющая минимизировать количество рендеров и повысить производительность веб-приложений на JS/TS, особенно в React.

---

> расскажи про типы never void any unknown

В TypeScript типы **never**, **void**, **any** и **unknown** играют важную роль в системе типов и безопасности кода. Вот подробное описание каждого из них:

### **any**

- **Описание:** Позволяет присваивать переменной _значение любого типа_ без проверки типов.
- **Использование:** При аннотации типа как `any`, компилятор TypeScript перестает проверять типы для этой переменной — можно обращаться к любым свойствам, вызывать любые методы и присваивать значения любых типов.
- **Рекомендуется избегать:** Так как теряется основное преимущество TypeScript — типобезопасность.

Пример:

```typescript
let anything: any = 42;
anything = "hello";
anything = [1, 2, 3];
```

### **unknown**

- **Описание:** _Типобезопасная альтернатива_ `any`. Можно присваивать значения любых типов, но **запрещено делать с ними что-либо, не проверив тип** (например, нельзя вызвать метод, не убедившись, что он существует).
- **Использование:** Полезен, когда заранее неизвестно, какое значение будет, но хочется сохранить безопасность типов.
- **Особенности:** `unknown` нельзя присвоить типу `string`, `number` и т.д. без явной проверки типа или приведения.

Пример:

```typescript
let maybe: unknown = 10;
maybe = "строка";
if (typeof maybe === "string") {
  // Теперь TypeScript знает, что maybe — строка
  console.log(maybe.toUpperCase());
}
```

### **void**

- **Описание:** Используется, чтобы явно указать — функция _ничего не возвращает_ (точнее, возвращает `undefined`).
- **Использование:** Как правило, в качестве возвращаемого типа функций, которые выполняют действие, но не возвращают осмысленного результата.
- **Особенности:** Можно встретить присваивание типа `void` переменным, но это не рекомендуется.

Пример:

```typescript
function log(message: string): void {
  console.log(message);
}
```

### **never**

- **Описание:** Обозначает _отсутствие значения вообще_. Используется для функций, которые никогда не завершаются _нормально_ (например, выбрасывают исключения или зацикливаются).
- **Использование:** Тип возвращаемого значения функций, которые завершают выполнение броском ошибки или бесконечным циклом.
- **Поведение:** Не содержит ни одного значения, даже `undefined` нельзя ему присвоить. Является подтипом любого типа, но ему нельзя присвоить ничего.

Пример:

```typescript
function throwError(message: string): never {
  throw new Error(message);
}

function infiniteLoop(): never {
  while (true) {}
}
```

### Сводная таблица сравнения

| Тип         | Описание                                                                           | Присваиваемые значения            | Назначение                                  |
| ----------- | ---------------------------------------------------------------------------------- | --------------------------------- | ------------------------------------------- |
| **any**     | Отключает проверку типов, всё разрешено.                                           | Любые                             | Быстрая разработка, нестрогий код           |
| **unknown** | Принимает любые значения, но требует проверки реального типа перед использованием. | Любые                             | Безопасная обработка "неизвестных" значений |
| **void**    | Отсутствие возвращаемого значения (обычно, `undefined`).                           | Только `undefined` (почти всегда) | Возвращаемый тип функций                    |
| **never**   | Значение не возникает никогда.                                                     | —                                 | Функции, которые не завершаются нормально   |

### Примечания и отличия

- `any` и `unknown` — супертупы для всех остальных: им можно присвоить любое значение, но `any` позволяет делать что угодно сразу, а с `unknown` — только после проверки типа.
- `never` — "пустой" тип, не содержит никаких значений и используется для описания невозможных ситуаций в коде.
- `void` — подходит для функций без результата (возвращает `undefined`), и почти всегда используется только как возвращаемый тип.

Эти типы являются отличительной особенностью TypeScript и позволяют гибко строить типовую систему, обеспечивая баланс между безопасностью и гибкостью.

---

> расскажи про типы данных в JS Map Set weakMap weakSet

## Коллекции Map, Set, WeakMap, WeakSet в JavaScript

В JavaScript, начиная с спецификации ES6, появились новые структуры данных — **Map**, **Set**, **WeakMap** и **WeakSet**. Они расширяют стандартные коллекции (например, объекты и массивы) и делают работу с данными удобнее и безопаснее.

### Map

- **Map** — коллекция пар "ключ-значение", где **ключом может быть значение любого типа** (включая объекты, функции и примитивы).
- **Порядок вставки**: Map сохраняет порядок добавления элементов.
- **Основные методы**:
  - `set(key, value)` — добавить значение по ключу;
  - `get(key)` — получить значение по ключу;
  - `has(key)` — проверить наличие ключа;
  - `delete(key)` — удалить элемент;
  - `clear()` — очистить всю коллекцию;
  - `size` — количество элементов в Map.
- **Пример**:
  ```js
  const map = new Map();
  map.set("a", 1);
  map.set({ b: 2 }, "object value");
  map.set(3, "number as key");
  // Получение
  map.get("a"); // 1
  ```
- **Чем отличается от объекта**: В объекте ключи всегда преобразуются к строке, а в Map ключи остаются тем типом, который вы задали.

### Set

- **Set** — коллекция **уникальных** значений любого типа (примитивы или объекты).
- **Не содержит повторяющихся элементов**. Если добавить одно и то же значение несколько раз — оно появится только один раз.
- **Основные методы**:
  - `add(value)` — добавить элемент;
  - `has(value)` — проверить наличие элемента;
  - `delete(value)` — удалить элемент;
  - `clear()` — очистить коллекцию;
  - `size` — число элементов.
- **Можно итерировать** с помощью for-of, forEach и специальных методов `values()`, `keys()`, `entries()`.
- **Пример**:
  ```js
  const set = new Set();
  set.add(1);
  set.add(2);
  set.add(2); // Не добавится!
  set.add("строка");
  set.has(1); // true
  ```
- **Отличие от массива**: В Set гарантируется уникальность значений и быстрый поиск.

### WeakMap

- **WeakMap** — коллекция пар "объект-значение", где **ключи обязательно являются объектами (или символами)**.
- **Ключи "слабо связаны"**: если объект-ключ не используется больше нигде, то его и соответствующую пару можно удалить сборщиком мусора.
- **Основные методы**:
  - `set(key, value)` — добавить элемент;
  - `get(key)` — получить значение по ключу;
  - `has(key)` — проверить наличие ключа;
  - `delete(key)` — удалить элемент.
- **Ограничения**:
  - Нельзя узнать размер коллекции.
  - Нельзя итерировать элементы (нет forEach, итераторов и т.п.).
- **Главная польза**: удобно хранить метаданные, связанные с объектами, не опасаясь утечек памяти (например, для кешей в DOM).

### WeakSet

- **WeakSet** — коллекция **уникальных объектов** (только объектов, не примитивов).
- Все объекты **"слабо связаны"** — если объект больше нигде не используется, он удаляется сборщиком мусора.
- **Основные методы**:
  - `add(value)` — добавить объект;
  - `has(value)` — проверить наличие;
  - `delete(value)` — удалить объект.
- **Ограничения**:
  - Нельзя узнать размер коллекции.
  - Нет методов для перебора элементов.
- **Применение**: удобно использовать для хранения приватных меток, трекинга состояния "был ли этот объект обработан" и прочего без риска утечки памяти.

#### Сравнительная таблица

| Тип     | Ключи          | Значения       | Итерация | Уникальность | Связь с GC (сборщиком мусора) |
| ------- | -------------- | -------------- | -------- | ------------ | ----------------------------- |
| Map     | Любой тип      | Любой тип      | Есть     | Нет          | Нет                           |
| Set     | —              | Любой тип      | Есть     | Да           | Нет                           |
| WeakMap | Только объекты | Любой тип      | Нет      | —            | Ключи удаляются GC            |
| WeakSet | —              | Только объекты | Нет      | Да           | Объекты удаляются GC          |

#### Итоги

- **Map** и **Set** — обычные коллекции с возможностью итерации и расширенными возможностями по сравнению с объектами и массивами.
- **WeakMap** и **WeakSet** — специальные коллекции для объектов с автоматическим удалением элементов сборщиком мусора, что предотвращает утечки памяти при динамической работе с объектами.

Используйте эти структуры по назначению — это сделает ваш код чище, производительнее и более надёжным!

---

> расскажи про useEffect и useLayoutEffect в react

## useEffect и useLayoutEffect в React

Эти два React-хука используются для управления **побочными эффектами** (side effects) в функциональных компонентах. Несмотря на похожие API, их основное отличие — _когда_ именно срабатывает эффект относительно жизненного цикла отрисовки компонента.

### useEffect

- **Назначение:** Выполнение побочных эффектов после рендера компонента – например, загрузка данных, подписки на события, настройка таймеров.
- **Время вызова:** Хук выполняется **асинхронно после того, как браузер отрисует изменения** на экране.
- **Типичные задачи:**
  - Ajax-запросы к API.
  - Навешивание и снятие слушателей событий.
  - Изменения невидимые для пользователя или не влияющие немедленно на DOM.

**Пример:**

```jsx
import { useEffect, useState } from "react";

function Example() {
  const [width, setWidth] = useState(window.innerWidth);

  useEffect(() => {
    const handleResize = () => setWidth(window.innerWidth);
    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, []);

  return <p>Window width: {width}</p>;
}
```

В этом примере слушатель события добавляется и удаляется через useEffect — компонент не блокирует отрисовку страницы.

### useLayoutEffect

- **Назначение:** Выполнение побочных эффектов, которые должны произойти **до того, как браузер покажет обновления пользователю**.
- **Время вызова:** Хук срабатывает **синхронно после всех изменений DOM, но до отрисовки браузером**. Это важно для задач, связанных с измерением и немедленным изменением DOM.
- **Когда использовать:** Когда нужны "чистые" визуальные изменения, измерения или синхронное обновление DOM для предотвращения "миганий" (flicker).
- **Важно:** useLayoutEffect блокирует визуальное обновление до окончания выполнения кода внутри хука — этим он потенциально может ухудшать производительность и потому должен использоваться только когда это действительно необходимо.

**Пример:**

```jsx
import { useLayoutEffect, useRef, useState } from "react";

function Tooltip({ targetRect }) {
  const ref = useRef(null);
  const [height, setHeight] = useState(0);

  useLayoutEffect(() => {
    if (ref.current) {
      setHeight(ref.current.getBoundingClientRect().height);
    }
  }, [targetRect]);

  return (
    <div ref={ref} style={{ top: targetRect.top - height }}>
      Подсказка
    </div>
  );
}
```

Здесь useLayoutEffect гарантирует, что измерение высоты произойдет до того, как браузер покажет пользователю результат — таким образом, положение подсказки будет корректным еще до визуальной отрисовки.

### Кратко: Главное различие

|                                  | useEffect                               | useLayoutEffect                                           |
| -------------------------------- | --------------------------------------- | --------------------------------------------------------- |
| **Когда срабатывает**            | После рендера и отрисовки браузером     | Сразу после рендера, до показа пользователю               |
| **Асинхронность**                | Да                                      | Нет, синхронно                                            |
| **Использовать, когда**          | Побочные эффекты, не влияющие на layout | Когда нужны измерения или синхронные изменения layout/DOM |
| **Влияет на производительность** | Нет                                     | Может замедлять рендер, если используется часто/heavy     |

### Практические рекомендации

- **95% случаев** используйте `useEffect` — это стандарт для большинства сайд-эффектов, не требующих немедленных изменений в DOM.
- `useLayoutEffect` — только если необходимы точные синхронные манипуляции с DOM перед показом изменений пользователю (например, при позиционировании tooltip'ов, анимациях, реалтайм-мерках).

**Вывод:**

- Оба хука служат для побочных эффектов в React.
- Главное отличие — момент исполнения: асинхронно после показа (`useEffect`) и синхронно до показа (`useLayoutEffect`).
- useLayoutEffect используйте только, если нужна полная синхронность манипуляций с DOM перед отрисовкой, иначе — предпочтительней useEffect.

**Краткий совет:**

> В большинстве проектов start with `useEffect`, а на `useLayoutEffect` переключайтесь только при визуальных проблемах, связанных с мерцанием или неправильным layout после обновлений компонента.

---

> Как можно оптимизировать загрузку компонентов в react?

## Оптимизация загрузки компонентов в React

Оптимизация загрузки компонентов в React позволяет ускорить время первого рендера и сделать приложение более отзывчивым для пользователя. Вот основные техники оптимизации:

### 1. Ленивaя подгрузка (Lazy Loading) с помощью React.lazy и Suspense

- **React.lazy** позволяет загружать компонент только тогда, когда он действительно потребуется — это уменьшает размер основного bundle и ускоряет первый рендер.
- **Suspense** используется для вывода fallback (например, спиннера), пока компонент загружается.

**Пример:**

```jsx
import React, { Suspense, lazy } from "react";

const MyComponent = lazy(() => import("./MyComponent"));

function App() {
  return (
    <Suspense fallback={<div>Загрузка...</div>}>
      <MyComponent />
    </Suspense>
  );
}
```

- Такой подход особенно эффективен для крупных или редко используемых компонентов.

### 2. Разделение кода (Code Splitting)

- **Разделение кода** — это разбиение приложения на небольшие части (чaнки), которые загружаются по мере необходимости.
- Используется совместно с динамическим импортом:
  ```js
  import("./SomeComponent").then(mod => ...);
  ```
- Современные сборщики (Webpack, Parcel) поддерживают code splitting "из коробки", а Create React App имеет настройки по умолчанию.

### 3. Ленивaя загрузка по маршрутам (Route-based Code Splitting)

- Подключайте крупные страницы или модули через lazy-загрузку в роутере:

  ```jsx
  import { lazy, Suspense } from "react";
  import { Routes, Route } from "react-router-dom";

  const AboutPage = lazy(() => import("./AboutPage"));

  <Suspense fallback={<div>Загрузка...</div>}>
    <Routes>
      <Route path="/about" element={<AboutPage />} />
    </Routes>
  </Suspense>;
  ```

- Особенно полезно, если приложение многостраничное.

### 4. Оптимизация загрузки тяжелых компонентов при скролле

- Используйте lazy loading для изображений, медиа и больших списков.
- Специализированные библиотеки, например, `react-window` или `react-lazyload`, рендерят только видимые элементы списка или секции, что существенно снижает нагрузку на DOM и ускоряет отклик интерфейса.

### 5. Предзагрузка по событию/фоновой активности

- Можно заранее подгрузить компонент или часть данных "в фоне", когда пользователь, например, наводит курсор на ссылку или замечена низкая активность.

### 6. Разделение контекста

- Храните разные данные в отдельных Context — это уменьшит лишние рендеры и ускорит приложение при изменениях состояния.

### 7. Работа с большими списками

- Для длинных списков используйте виртуальный рендеринг (`react-window`, `react-virtualized`) чтобы создавать в DOM только те элементы, которые реально видимы на экране.

### Кратко в таблице

| Метод                   | Описание                                   | Эффект                                         |
| ----------------------- | ------------------------------------------ | ---------------------------------------------- |
| React.lazy/Suspense     | Ленивaя загрузка компонентов               | Меньше bundle, быстрее первый рендер           |
| Code Splitting          | Разделение кода на чанки                   | Загружается только нужный код                  |
| Lazy routes             | Загрузка страниц только по маршруту        | Быстрее роутинг, меньше трафика                |
| Lazy lists/images       | Рендер только видимого/отложенная загрузка | Быстрее scroll и работа со списками            |
| Предзагрузка по событию | Прогрузка по hover или при простое         | Гораздо меньше лагов при переходе              |
| Оптимизация Context     | Разделение контекстов                      | Меньше лишних рендеров, быстрее обновления     |
| Виртуализация списков   | Только видимые элементы в DOM              | Огромный прирост производительности на списках |

### Практические советы

- Не делайте ленивой загрузкой критические для первого экрана компоненты — это может ухудшить LCP (Largest Contentful Paint).
- Старайтесь разбивать бандл осмысленно: крупные и редко используемые компоненты/страницы — на отдельные чанки, но не дробите слишком мелко — это усложнит загрузку.
- Следите за профилированием и пользуйтесь инструментами типа React Profiler для анализа времени рендера и поиска "узких мест".

**Вывод:**  
Оптимизация загрузки компонентов в React строится вокруг ленивой загрузки, разделения кода и эффективного рендеринга. Компетентное применение этих практик заметно ускоряет работу большого приложения и улучшает пользовательский опыт.

---

> расскажи про useCallback useMemo в react

## useCallback и useMemo в React

В React хуки **useCallback** и **useMemo** применяются для оптимизации производительности компонентов — они предотвращают ненужные пересоздания функций и значений между рендерами.

### useCallback

**useCallback** — хук, который возвращает мемоизированную (запоминаемую) версию функции, и эта функция будет пересоздаваться только при изменении значений в массиве зависимостей.

#### Когда нужен:

- Чтобы не создавать новую функцию при каждом рендере компонента.
- Для передачи функций в дочерние компоненты, особенно если дочерний компонент обёрнут в `React.memo` (т.е. «запоминается» и перерисовывается только если props поменялись).
- Может предотвратить лишние рендеры дочерних компонентов.

#### Синтаксис:

```jsx
const memoizedCallback = useCallback(() => {
  // callback logic
}, [dependencies]);
```

#### Пример использования:

```jsx
import React, { useState, useCallback } from "react";

const Button = React.memo(({ onClick }) => {
  console.log("Button rerendered");
  return <button onClick={onClick}>Click</button>;
});

function App() {
  const [count, setCount] = useState(0);

  const increment = useCallback(() => setCount((c) => c + 1), []);
  // increment не будет создаваться заново при каждом рендере

  return (
    <div>
      <span>{count}</span>
      <Button onClick={increment} />
    </div>
  );
}
```

**Важно:** Используйте useCallback только если дочерний компонент действительно выигрывает от фиксированного reference функции.

### useMemo

**useMemo** — хук для мемоизации результата вычисления между рендерами. Он выполняет функцию-вычисление только при изменении указанных зависимостей и возвращает кэшированное значение.

#### Когда использовать:

- Для избежания повторных затратных вычислений (например, фильтрация, подсчёты, работа с большими массивами).
- При передаче сложных вычисленных значений в дочерние компоненты, чтобы их props не создавались заново при каждом рендере.
- Для стабильности ссылочных типов (массивы, объекты), чтобы не триггерить избыточные рендеры.

#### Синтаксис:

```jsx
const memoizedValue = useMemo(() => {
  return computeExpensiveValue(a, b);
}, [a, b]);
```

#### Пример использования:

```jsx
import React, { useMemo, useState } from "react";

function ExpensiveList({ items, filter }) {
  const filteredItems = useMemo(
    () => items.filter((item) => item.includes(filter)),
    [items, filter]
  );
  // filteredItems будет вычисляться только если items или filter изменились

  return (
    <ul>
      {filteredItems.map((i) => (
        <li key={i}>{i}</li>
      ))}
    </ul>
  );
}
```

**Заметки:** Не стоит применять useMemo для всего подряд. Используйте его для действительно дорогих вычислений или для стабилизации props в цепочках оптимизации.

### Основные отличия useCallback и useMemo

| useCallback                                                                    | useMemo                                                                            |
| ------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------- |
| Кэширует функцию                                                               | Кэширует результат выполнения функции                                              |
| Используется для предотвращения лишних пересозданий функций (обычно для props) | Используется для предотвращения лишних расчетов и создания новых объектов/массивов |
| Возвращает функцию                                                             | Возвращает значение                                                                |
| Применяется часто с React.memo                                                 | Особенно полезен для дорогих вычислений                                            |

Простое правило:  
— Нужно запоминать функцию → **useCallback**  
— Нужно запоминать вычисленное значение → **useMemo**.

### Итог

- **useCallback** не даёт пересоздаваться функции без причин.
- **useMemo** не даёт лишний раз пересчитывать тяжёлое значение.
- Оба используются **именно там**, где это может сэкономить ресурсы вашего приложения и избежать лишних рендеров.

Избегайте их «на всякий случай»: неправильное и избыточное применение усложняет код и не ускоряет приложение.

---

> Расскажи про дженерики в TS?

**Дженерики** (generics, обобщения) в TypeScript — это механизм, позволяющий создавать универсальные функции, интерфейсы и классы, которые работают с разными типами данных, сохраняя при этом строгую типовую безопасность. Дженерики позволяют избежать дублирования кода и делают функции и структуры данных гибче.

### Основная идея

Дженерики позволяют создавать компоненты (функции, классы, интерфейсы), в которых тип данных не фиксирован, а задаётся позднее — при использовании этого компонента. Это выглядит так:

```typescript
function identity<T>(arg: T): T {
  return arg;
}

let output1 = identity<string>("myString"); // output1: string
let output2 = identity<number>(100); // output2: number
```

Здесь `T` — параметр типа (generic parameter), который будет подставлен вызовом функции.

### Где применяются дженерики

- **Функции**  
  Позволяют создавать функции, работающие с разными типами:
  ```typescript
  function reverse<T>(items: T[]): T[] {
    return items.reverse();
  }
  ```
- **Классы**  
  Позволяют создать универсальные структуры данных:
  ```typescript
  class Queue<T> {
    private data: T[] = [];
    push(item: T) {
      this.data.push(item);
    }
    pop(): T | undefined {
      return this.data.shift();
    }
  }
  let numberQueue = new Queue<number>();
  let stringQueue = new Queue<string>();
  ```
- **Интерфейсы** и **типы**
  ```typescript
  interface Pair<T, U> {
    first: T;
    second: U;
  }
  const pair: Pair<number, string> = { first: 1, second: "one" };
  ```

---

### Ограничения дженериков (Generic Constraints)

Если нужно ограничить, какие типы можно подставлять в дженерик, используют `extends`:

```typescript
interface Lengthwise {
  length: number;
}

function getLength<T extends Lengthwise>(arg: T): number {
  return arg.length;
}
```

Теперь функция принимает только те типы, у которых есть свойство `length` — строка, массив и т.д.

### Примеры полезных дженериков

#### Доступ к свойству объекта:

```typescript
function getPropertyValue<Obj, Key extends keyof Obj>(
  obj: Obj,
  key: Key
): Obj[Key] {
  return obj[key];
}
// getPropertyValue({a: 2, b: 3}, 'a'); // ok
// getPropertyValue({a: 2, b: 3}, 'c'); // ошибка
```

Здесь `Key` ограничен возможными ключами объекта `Obj`.

### Автоматический вывод типов

В большинстве случаев TypeScript может сам определить тип дженерика на основании переданных аргументов:

```typescript
function foo<T>(value: T): T[] {
  return [value];
}
const arr = foo(1); // arr: number[]
```

---

### Практическая польза дженериков

- **Гибкость и повторное использование**: Один и тот же компонент/функция работает с любыми типами, экономя время и уменьшает ошибочность.
- **Типовая безопасность**: Нельзя случайно передать данные не того типа. TypeScript всё проверит на этапе компиляции.
- **Замена any**: Дженерики позволяют не использовать тип any, сохраняя контроль типов.

### Итоги

- **Дженерики** позволяют создавать универсальные структуры, работающие с разными типами данных, избегая дублирования кода и сохраняя строгую типизацию.
- Они поддерживаются в функциях, классах, интерфейсах, типаx и могут иметь ограничения.
- Используйте их, если ваш компонент должен корректно работать с данными разного типа, но важно сохранить контроль за ними на этапе компиляции.

---

> Расскажи про hook в react?

**Хук (hook) в React** — это специальная функция, которая позволяет функциональным компонентам использовать внутреннее состояние, методы жизненного цикла и другие возможности React без необходимости писать классы.

### Основная идея

- Хуки появились в React 16.8 как замена классическим компонентам с их сложным синтаксисом и методами жизненного цикла.
- Благодаря хукам вы можете добавлять функциональность (например, хранение состояния или работу с побочными эффектами) напрямую в функциональные компоненты, делая код чище, короче и легче для повторного использования.

### Для чего нужны хуки

- **Добавление состояния** (state) в функциональные компоненты.
- **Управление побочными эффектами** (effects) — например, загрузка данных, подписки на события.
- **Логика работы с жизненным циклом** (например, действия при монтировании, обновлении или удалении компонента).
- **Повторное использование логики между компонентами** через пользовательские хуки.
- Построение модульного, легко поддерживаемого и расширяемого кода.

### Примеры встроенных хуков

- **useState** — добавляет локальное состояние в компонент.

  ```js
  const [count, setCount] = useState(0);
  ```

- **useEffect** — позволяет управлять побочными эффектами:

  ```js
  useEffect(() => {
    document.title = `Вы нажали ${count} раз`;
  }, [count]);
  ```

- **useContext, useRef, useMemo, useCallback, useReducer** — дополнительные хуки для доступа к контексту, рефам, мемоизации, кэшированию функций и сложного управления состоянием соответственно.

### Основные правила использования хуков

- **Использовать только внутри функциональных компонентов** или внутри других хуков.
- **Вызывать хуки только на верхнем уровне** — нельзя вставлять вызовы хуков в циклы, условия или вложенные функции, чтобы React мог правильно отслеживать порядок вызовов и соответствие состояния.

### Пользовательские хуки

- Кроме встроенных, разработчик может создавать кастомные хуки для повторного использования логики между разными компонентами.

### Почему это важно

- **Упрощает архитектуру**: сокращает необходимость классов, делает компоненты более компактными и читаемыми.
- **Облегчает повторное использование кода**: вынесенная в хуки логика может переиспользоваться в разных частях приложения.
- **Единая модель компонентов**: современные React-приложения почти полностью состоят из функциональных компонентов с хуками.

**Кратко:**  
**Хуки** — это функции, которые делают функциональные компоненты в React «умными»: позволяют хранить состояние и работать с жизненным циклом без сложностей классового синтаксиса, делая код легче, модульней и более гибким.

---

> Расскжи про понятние генераторов в TS?

## Генераторы в TypeScript

**Генераторы** — это специальный тип функций, которые могут «приостанавливать» своё выполнение и возвращать значения по требованию. Генераторы существуют в JavaScript и полностью поддерживаются в TypeScript, но с дополнительными возможностями типизации.

### Основные особенности генераторов

- **Создание**: Генератор определяется с помощью ключевого слова `function*`.
  ```typescript
  function* simpleGenerator() {
    yield 1;
    yield 2;
    yield 3;
  }
  ```
- **Вызов генератора** не запускает его код сразу, а возвращает объект-генератор. Для получения результата используется метод `.next()`:
  ```typescript
  const gen = simpleGenerator();
  console.log(gen.next().value); // 1
  console.log(gen.next().value); // 2
  console.log(gen.next().value); // 3
  console.log(gen.next().done); // true
  ```
- **Пауза и возобновление**: выполнение генератора можно приостанавливать (`yield`) и продолжать с того же места.

### Типизация генераторов в TS

TypeScript позволяет явно указывать типы значений, которые генератор возвращает, принимает через `next`, и тип значения, возвращаемого при завершении выполнения (`return`):

```typescript
function* numberGen(): Generator<number, string, void> {
  yield 1;
  yield 2;
  yield 3;
  return "done";
}
```

В этой записи:

- Первый параметр (`number`) — тип значения, возвращаемого через `yield`.
- Второй (`string`) — тип значения, возвращаемого оператором `return` при завершении генератора.
- Третий (`void`) — тип значения, которое может быть передано внутрь генератора через `next(value)`.

### Ключевые понятия

- **Ленивая последовательность (lazy evaluation)**: значения вычисляются только по запросу, что экономит память и ускоряет работу с большими или бесконечными последовательностями.
- **Итерируемость**: генератор можно перебирать в цикле `for...of`.
- **Композиция**: через `yield*` генератор может делегировать выполнение другому генератору.
- **Обработка ошибок**: в генераторы можно «закидывать» ошибки с помощью `.throw()`. Это позволяет строить сложные управляющие структуры.

### Примеры

#### Базовый генератор

```typescript
function* alphabet(): Generator<string> {
  yield "A";
  yield "B";
  yield "C";
}
for (const letter of alphabet()) {
  console.log(letter); // A, B, C
}
```

#### Ленивый генератор Фибоначчи

```typescript
function* fibonacci(): Generator<number> {
  let a = 0,
    b = 1;
  yield a;
  yield b;
  while (true) {
    const next = a + b;
    yield next;
    a = b;
    b = next;
  }
}
// Получить 5 первых чисел
const fib = fibonacci();
for (let i = 0; i < 5; i++) {
  console.log(fib.next().value); // 0 1 1 2 3
}
```

> Такой генератор не тратит память на хранение всего ряда сразу.

### Использование на практике

- **Создание ленивых коллекций и итераторов** (фильтрация, карты, pipeline).
- **Работа с большими объёмами данных** — последовательная обработка или загрузка по частям (например, чтение строк из файла).
- **Асинхронное программирование** (на уровне синхронных коллекций).

### Отличия от обычных функций

| Обычная функция                             | Генератор                                 |
| ------------------------------------------- | ----------------------------------------- |
| Выполняется до конца сразу                  | Выполнение прерывается и возобновляется   |
| Возвращает только один результат (`return`) | Может возвращать много значений (`yield`) |
| Нет внутреннего состояния между вызовами    | Сохраняет своё состояние между вызовами   |

### Итоги

- Генератор — это функция, выполнение которой можно **приостанавливать и возобновлять**, выдавая значения по запросу.
- В TypeScript их можно типизировать для большей безопасности.
- Генераторы отлично подходят для ленивых вычислений, работы с потоками данных и построения сложных итерационных процессов.

---

> Как можно оптимизировать загрузку компонентов в react?

## Оптимизация загрузки компонентов в React

Оптимизация загрузки компонентов в React позволяет ускорить время первого рендера и сделать приложение более отзывчивым для пользователя. Вот основные техники оптимизации:

### 1. Ленивaя подгрузка (Lazy Loading) с помощью React.lazy и Suspense

- **React.lazy** позволяет загружать компонент только тогда, когда он действительно потребуется — это уменьшает размер основного bundle и ускоряет первый рендер.
- **Suspense** используется для вывода fallback (например, спиннера), пока компонент загружается.

**Пример:**

```jsx
import React, { Suspense, lazy } from "react";

const MyComponent = lazy(() => import("./MyComponent"));

function App() {
  return (
    <Suspense fallback={<div>Загрузка...</div>}>
      <MyComponent />
    </Suspense>
  );
}
```

- Такой подход особенно эффективен для крупных или редко используемых компонентов.

### 2. Разделение кода (Code Splitting)

- **Разделение кода** — это разбиение приложения на небольшие части (чaнки), которые загружаются по мере необходимости.
- Используется совместно с динамическим импортом:
  ```js
  import("./SomeComponent").then(mod => ...);
  ```
- Современные сборщики (Webpack, Parcel) поддерживают code splitting "из коробки", а Create React App имеет настройки по умолчанию.

### 3. Ленивaя загрузка по маршрутам (Route-based Code Splitting)

- Подключайте крупные страницы или модули через lazy-загрузку в роутере:

  ```jsx
  import { lazy, Suspense } from "react";
  import { Routes, Route } from "react-router-dom";

  const AboutPage = lazy(() => import("./AboutPage"));

  <Suspense fallback={<div>Загрузка...</div>}>
    <Routes>
      <Route path="/about" element={<AboutPage />} />
    </Routes>
  </Suspense>;
  ```

- Особенно полезно, если приложение многостраничное.

### 4. Оптимизация загрузки тяжелых компонентов при скролле

- Используйте lazy loading для изображений, медиа и больших списков.
- Специализированные библиотеки, например, `react-window` или `react-lazyload`, рендерят только видимые элементы списка или секции, что существенно снижает нагрузку на DOM и ускоряет отклик интерфейса.

### 5. Предзагрузка по событию/фоновой активности

- Можно заранее подгрузить компонент или часть данных "в фоне", когда пользователь, например, наводит курсор на ссылку или замечена низкая активность.

### 6. Разделение контекста

- Храните разные данные в отдельных Context — это уменьшит лишние рендеры и ускорит приложение при изменениях состояния.

### 7. Работа с большими списками

- Для длинных списков используйте виртуальный рендеринг (`react-window`, `react-virtualized`) чтобы создавать в DOM только те элементы, которые реально видимы на экране.

### Кратко в таблице

| Метод                   | Описание                                   | Эффект                                         |
| ----------------------- | ------------------------------------------ | ---------------------------------------------- |
| React.lazy/Suspense     | Ленивaя загрузка компонентов               | Меньше bundle, быстрее первый рендер           |
| Code Splitting          | Разделение кода на чанки                   | Загружается только нужный код                  |
| Lazy routes             | Загрузка страниц только по маршруту        | Быстрее роутинг, меньше трафика                |
| Lazy lists/images       | Рендер только видимого/отложенная загрузка | Быстрее scroll и работа со списками            |
| Предзагрузка по событию | Прогрузка по hover или при простое         | Гораздо меньше лагов при переходе              |
| Оптимизация Context     | Разделение контекстов                      | Меньше лишних рендеров, быстрее обновления     |
| Виртуализация списков   | Только видимые элементы в DOM              | Огромный прирост производительности на списках |

### Практические советы

- Не делайте ленивой загрузкой критические для первого экрана компоненты — это может ухудшить LCP (Largest Contentful Paint).
- Старайтесь разбивать бандл осмысленно: крупные и редко используемые компоненты/страницы — на отдельные чанки, но не дробите слишком мелко — это усложнит загрузку.
- Следите за профилированием и пользуйтесь инструментами типа React Profiler для анализа времени рендера и поиска "узких мест".

**Вывод:**  
Оптимизация загрузки компонентов в React строится вокруг ленивой загрузки, разделения кода и эффективного рендеринга. Компетентное применение этих практик заметно ускоряет работу большого приложения и улучшает пользовательский опыт.

---

> Раскажи про типы never void any unknown?

В TypeScript типы **never**, **void**, **any** и **unknown** играют важную роль в системе типов и безопасности кода. Вот подробное описание каждого из них:

### **any**

- **Описание:** Позволяет присваивать переменной _значение любого типа_ без проверки типов.
- **Использование:** При аннотации типа как `any`, компилятор TypeScript перестает проверять типы для этой переменной — можно обращаться к любым свойствам, вызывать любые методы и присваивать значения любых типов.
- **Рекомендуется избегать:** Так как теряется основное преимущество TypeScript — типобезопасность.

Пример:

```typescript
let anything: any = 42;
anything = "hello";
anything = [1, 2, 3];
```

### **unknown**

- **Описание:** _Типобезопасная альтернатива_ `any`. Можно присваивать значения любых типов, но **запрещено делать с ними что-либо, не проверив тип** (например, нельзя вызвать метод, не убедившись, что он существует).
- **Использование:** Полезен, когда заранее неизвестно, какое значение будет, но хочется сохранить безопасность типов.
- **Особенности:** `unknown` нельзя присвоить типу `string`, `number` и т.д. без явной проверки типа или приведения.

Пример:

```typescript
let maybe: unknown = 10;
maybe = "строка";
if (typeof maybe === "string") {
  // Теперь TypeScript знает, что maybe — строка
  console.log(maybe.toUpperCase());
}
```

### **void**

- **Описание:** Используется, чтобы явно указать — функция _ничего не возвращает_ (точнее, возвращает `undefined`).
- **Использование:** Как правило, в качестве возвращаемого типа функций, которые выполняют действие, но не возвращают осмысленного результата.
- **Особенности:** Можно встретить присваивание типа `void` переменным, но это не рекомендуется.

Пример:

```typescript
function log(message: string): void {
  console.log(message);
}
```

### **never**

- **Описание:** Обозначает _отсутствие значения вообще_. Используется для функций, которые никогда не завершаются _нормально_ (например, выбрасывают исключения или зацикливаются).
- **Использование:** Тип возвращаемого значения функций, которые завершают выполнение броском ошибки или бесконечным циклом.
- **Поведение:** Не содержит ни одного значения, даже `undefined` нельзя ему присвоить. Является подтипом любого типа, но ему нельзя присвоить ничего.

Пример:

```typescript
function throwError(message: string): never {
  throw new Error(message);
}

function infiniteLoop(): never {
  while (true) {}
}
```

### Сводная таблица сравнения

| Тип         | Описание                                                                           | Присваиваемые значения            | Назначение                                  |
| ----------- | ---------------------------------------------------------------------------------- | --------------------------------- | ------------------------------------------- |
| **any**     | Отключает проверку типов, всё разрешено.                                           | Любые                             | Быстрая разработка, нестрогий код           |
| **unknown** | Принимает любые значения, но требует проверки реального типа перед использованием. | Любые                             | Безопасная обработка "неизвестных" значений |
| **void**    | Отсутствие возвращаемого значения (обычно, `undefined`).                           | Только `undefined` (почти всегда) | Возвращаемый тип функций                    |
| **never**   | Значение не возникает никогда.                                                     | —                                 | Функции, которые не завершаются нормально   |

### Примечания и отличия

- `any` и `unknown` — супертупы для всех остальных: им можно присвоить любое значение, но `any` позволяет делать что угодно сразу, а с `unknown` — только после проверки типа.
- `never` — "пустой" тип, не содержит никаких значений и используется для описания невозможных ситуаций в коде.
- `void` — подходит для функций без результата (возвращает `undefined`), и почти всегда используется только как возвращаемый тип.

Эти типы являются отличительной особенностью TypeScript и позволяют гибко строить типовую систему, обеспечивая баланс между безопасностью и гибкостью.

---

```typescript
// Дан массив arr = [1 , 8, 3, 9, 12, 13, 2, 5, 6], необходимо отсортировать четные числа по возрастанию и оставить их на месте.

function sortEvenNumbers(arr) {
  // Извлекаем четные числа и сортируем их
  const evenNumbers = arr.filter((num) => num % 2 === 0).sort((a, b) => a - b);

  // Создаем копию массива для результата
  const result = [...arr];

  // Индекс для отсортированных четных чисел
  let evenIndex = 0;

  // Заменяем четные числа на отсортированные
  for (let i = 0; i < result.length; i++) {
    if (result[i] % 2 === 0) {
      result[i] = evenNumbers[evenIndex];
      evenIndex++;
    }
  }

  return result;
}

// variant 2
function sortEvenNumbers(arr) {
  const evens = arr.filter((x) => x % 2 === 0).sort((a, b) => a - b);
  let evenIndex = 0;
  return arr.map((x) => (x % 2 === 0 ? evens[evenIndex++] : x));
}

// variant 3
function sortEvenNumbers(arr) {
  const evens = arr.filter((x) => x % 2 === 0).sort((a, b) => a - b);
  return arr.reduce((result, num, index) => {
    result.push(num % 2 === 0 ? evens.shift() : num);
    return result;
  }, []);
}

// Тестируем с вашим массивом
const arr = [1, 8, 3, 9, 12, 13, 2, 5, 6];
const result = sortEvenNumbers(arr);

console.log("Исходный массив:", arr);
console.log("Результат:", result);
```
