# Основы и типизация

Отличия от JavaScript, типы данных, type vs interface, union/intersection типы, type inference

---

### Основы и типизация

<details>
<summary>Объясните ключевые отличия между TypeScript и JavaScript</summary>
Краткий ответ:  
TypeScript — это статически типизированное надмножество JavaScript, добавляющее строгую проверку типов и поддерживающее современные возможности языка ещё до их появления в стандарте JavaScript.

Пример кода:

```typescript
// TypeScript
function greet(name: string): string {
  return `Hello, ${name}`;
}

let x: number = 123; // Ошибка при попытке присвоить строку
```

```javascript
// JavaScript (аналогичный код)
function greet(name) {
  return `Hello, ${name}`;
}

let x = 123; // Можно присвоить строку без ошибок
```

Почему и когда использовать TypeScript:  
TypeScript снижает риск ошибок благодаря статической типизации, автодополнению и насильной (enforced) документации API. Он применим в крупных командах и проектах с долгим жизненным циклом, где важно управлять сложностью, повышать надёжность и ускорять сопровождение кода.

Реальные сценарии:

- **Разработка большого frontend-приложения (React, Angular)**: минимизация багов и ускорение ревью.
- **Интеграция с backend-API**: строгие описания интерфейсов и моделей данных.
- **Поддержка мультикомандных проектов**: типы выступают как документация для новых участников.

Подводные камни и best practices:

- TypeScript требует настройки сборки и дополнительного обучения.
- Слабое покрытие типами (any, unknown) лишает преимущества TS — избегайте их без необходимости.
- Переписывая существующий JS-проект, начинайте с постепенного введения типов через JSDoc либо строгий режим (--strict).
- Следите за синхронизацией версий библиотек и их типов (DefinitelyTyped).

Резюме ключевых моментов:

- TypeScript = JavaScript + строгая типизация и расширенный синтаксис.
- Используйте TS для надёжности, масштабируемости и сокращения числа ошибок.
- Начинайте внедрение поэтапно; избегайте типизации “для галочки”.
- JavaScript остаётся исполняемым кодом — TS всегда компилируется в JS.

</details>

<details>
<summary>Какие типы данных доступны в TypeScript?</summary>
Краткий ответ:  
В TypeScript доступны как все стандартные типы данных JavaScript, так и расширенные типы, включая примитивы, сложные и особые типы.

Пример кода для основных типов:

```typescript
// Примитивные типы
let isActive: boolean = true;
let count: number = 42;
let username: string = "Alex";

// Специальные типы
let id: undefined = undefined;
let  null = null;
let anyValue: any = "Можно присвоить любой тип";
let unknownValue: unknown = "Требует проверки перед использованием";

// Сложные типы
let user: { id: number; name: string } = { id: 1, name: "Irina" };
let tags: string[] = ["ts", "js"];
let point: [number, number] = [5, 10];
let multiply: (a: number, b: number) => number = (a, b) => a * b;

// Собственные типы
type UserId = string | number;
let uid: UserId = 1001;

// Литеральные, enum, never, void
let direction: "left" | "right" = "left";
enum Status { Active, Inactive }
function log(msg: string): void { console.log(msg); }
function fail(): never { throw new Error("Ошибка"); }
```

Почему и когда использовать:

- **Примитивные типы** (number, string, boolean): для базовых сущностей.
- **Кастомные типы, интерфейсы, union и intersection**: для сложных структур, API-моделей или бизнес-логики.
- **Enum**: для ограниченного набора вариантов (например, статусы).
- **Tuple**: для фиксированных массивов с элементами разных типов.
- **Any/unknown**: только в крайних случаях для интеграции со сторонним кодом или при пошаговой миграции.

Реальные сценарии:

- Загрузка данных из API: типы объектов и массивов.
- Валидация пользовательских данных: union и literal types.
- Типизация функций с предсказуемыми аргументами и значениями.

Подводные камни и best practices:

- Избегайте `any`, используйте `unknown` для неизвестных значений (требует проверки типов).
- Типизация через интерфейсы и типы (`interface`, `type`) масштабируется лучше, чем через повторение аннотаций.
- Не путая “null” и “undefined”, учитывайте строгий режим (`--strictNullChecks`).

Резюме ключевых моментов:

- TypeScript поддерживает примитивные, сложные, объединённые и кастомные типы.
- Используйте точную типизацию ради надёжности и поддержки.
- “any” — временная уступка; типы и интерфейсы = долгосрочная документация и безопасность.

</details>

<details>
<summary>В чем разница между type и interface в TypeScript?</summary>
Краткий ответ:  
`interface` и `type` используются для типизации объектов в TypeScript, но `interface` предназначен в первую очередь для описания структуры объектов и легко расширяется, а `type` универсальнее и поддерживает объединения, пересечения и алиасы любых типов.

Практические примеры кода:

```typescript
// interface — расширяемый контракт для объектов и классов
interface User {
  id: number;
  name: string;
}

// Расширение интерфейса
interface Admin extends User {
  permissions: string[];
}

// type — алиас для любых типов, поддерживает union/intersection
type ID = string | number;
type UserRole = "user" | "admin";
type UserWithRole = User & { role: UserRole };

// Отличие в расширяемости
interface Extended extends User {} // ок
type ExtendedType = User & {}; // тоже ок, но менее прозрачно
```

Почему и когда использовать:

- **interface** предпочтителен для описания структуры объектов, классов, публичных API и компонентов (особенно в React), так как легко расширяется и поддерживает декларативное наследование.
- **type** нужен для сложных комбинаций типов, объединений (union), пересечений (intersection), типизации примитивов, массивов, кортежей, функций и т.д.

Реальные сценарии:

- Типизация пропсов в React: interface для props-компонентов.
- Описание DTO/API-моделей: interface для структуры, type для alias ID/статусов.
- При интеграции с внешними библиотеками или при миграции с JS: type для сложных описаний или временных алиасов.

Подводные камни и best practices:

- Не используйте type только для объектов — interface легче поддерживать и расширять.
- Не смешивайте interface и type для одной структуры, во избежание конфликтов.
- Для публичных API, библиотек и крупных приложений предпочтительней interface.
- Для сложных объединённых типов, tuple, функции — выбирайте type.

Резюме ключевых моментов:

- interface — для описания объектов и расширения (extends/implements).
- type — для алиасов, объединений и сложных композиций.
- Правильный выбор улучшает поддержку, читаемость и масштабирование вашего кода.

</details>

<details>
<summary>Что такое union и intersection типы? Приведите примеры</summary>
Краткий ответ:  
Union (объединение) и intersection (пересечение) — это мощные конструкции TypeScript для объединения и компоновки типов: union описывает значения, которые могут принадлежать нескольким типам, intersection требует одновременного соответствия нескольким типам.

Примеры кода:

```typescript
// Union type — значение одного из нескольких типов
type Id = string | number;
let x: Id = "abc"; // OK
x = 123; // OK
// x = true;       // Ошибка

// Intersection type — объект должен соответствовать нескольким типам одновременно
type Animal = { paws: number };
type Pet = { name: string };
type Cat = Animal & Pet;

const myCat: Cat = { paws: 4, name: "Murka" }; // OK
// const invalidCat: Cat = { paws: 4 };        // Ошибка — нет name
```

Почему и когда использовать:

- **Union** применяйте, когда переменная, аргумент или проп может быть разных “однородных” типов (например, идентификатор — строка или число).
- **Intersection** нужен, когда требуется объект, сочетающий несколько аспектов (например, сущность с признаками нескольких интерфейсов).

Реальные сценарии:

- API, в которых входные параметры могут приходить в разном формате (например, id: string | number).
- Фронтенд-формы с разными вариантами формата данных на разных этапах.
- Компоновка props-компонентов в React при использовании HOC или миксинов.

Подводные камни и best practices:

- Не используйте большие union с разнородными типами — это усложняет логику и проверки типов.
- При intersection конфликты одноимённых свойств приводят к ошибкам компиляции.
- Для union с литеральными значениями удобно применять type guard-функции и pattern matching (switch).

Резюме ключевых моментов:

- Union — “или”, intersection — “и” для типов.
- Используйте union для гибкости данных, intersection — для склеивания возможностей нескольких структур.
- Эти конструкции повышают выразительность и надёжность типизации.

</details>

<details>
<summary>Как работает type inference в TypeScript?</summary>

</details>
