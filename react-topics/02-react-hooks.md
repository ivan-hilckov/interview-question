# React Hooks

useState, useEffect, useContext, useCallback, useMemo, кастомные хуки

---

### React Hooks

<details>
  <summary>Объясните значение React Hooks в современной разработке и чем они отличаются от классовых компонентов</summary>
  # Значение React Hooks в современной разработке и отличие от классовых компонентов

**React Hooks** — это функции, которые позволяют "подключаться" к возможностям React (таким как состояние, контекст, side effects) прямо в функциональных компонентах, без использования классов[1][2].

## Почему Hooks стали важны для современной разработки?

### 1. **Стандарт современного React**

- Начиная с версии 16.8 (2019), Hooks стали **основным способом управления состоянием и жизненным циклом** компонента.
- В 2025 году почти все новые проекты и актуальные библиотеки используют Hooks, а классы применяются в основном при поддержке legacy-кода[1][3].

### 2. **Синтаксическая простота и читаемость**

- Функциональный компонент с хуками намного проще и короче, чем классовый аналог. Нет `this`, нет конструкторов, нет сложных привязок методов:

  ```js
  // Классовый компонент
  class Counter extends React.Component {
    state = { value: 0 };
    increment = () => this.setState({ value: this.state.value + 1 });
    render() {
      return <button onClick={this.increment}>{this.state.value}</button>;
    }
  }

  // Функциональный компонент с useState
  function Counter() {
    const [value, setValue] = useState(0);
    return <button onClick={() => setValue(value + 1)}>{value}</button>;
  }
  ```

- Это повышает читаемость и снижает entry barrier для новичков[2][3].

### 3. **Переиспользование логики (custom hooks)**

- Hooks позволяют выносить бизнес-логику в отдельные функции — **кастомные хуки**. Их можно переиспользовать в разных компонентах без HOC и render props[2][4].
  ```js
  // Пример кастомного hook'а
  function useUserData(userId) {
    const [user, setUser] = useState(null);
    useEffect(() => {
      fetchUser(userId).then(setUser);
    }, [userId]);
    return user;
  }
  // Использование
  function UserCard({ userId }) {
    const user = useUserData(userId);
    return <div>{user?.name}</div>;
  }
  ```

### 4. **Лучшая композиция и организация кода**

- Вместо того чтобы разносить связанную логику по разным lifecycle-методам класса, хуки позволяют **группировать связанную логику** рядом друг с другом внутри одного компонента (разделение concern'ов)[4][1].

### 5. **Гибкость и современные возможности**

- Хуки (например, `useEffect`, `useReducer`, `useContext`) дают доступ ко всем возможностям React, в том числе тем, которые были доступны только в классах — управлению побочными эффектами, сложным состоянием, референсам, подпискам и т.д.[2][4].
- Hooks легко интегрируются с TypeScript, новым Concurrent Mode, Suspense и прочими новшествами последних лет[1].

## Ключевые отличия Hooks от классовых компонентов

| Аспект               | Хуки (Hooks)                          | Классовые компоненты              |
| -------------------- | ------------------------------------- | --------------------------------- |
| Синтаксис            | Обычные функции                       | Наследование от `React.Component` |
| Управление state     | `useState`, `useReducer`              | this.state, this.setState         |
| Жизненный цикл       | `useEffect`                           | componentDidMount/Update/Unmount  |
| Переиспользование    | Кастомные хуки                        | HOC/render props                  |
| Читаемость           | Проще и короче                        | Более многословные                |
| Связка с `this`      | Нет                                   | Необходимость bind-ить методы     |
| Производительность   | Более гибкая оптимизация              | Более громоздкая архитектура      |
| Современные паттерны | Поддерживаются (Suspense, Concurrent) | Ограничено                        |

## Из чего складывается сила Hooks?

- **Меньше boilerplate и ошибок**: не нужно помнить о bind, замыканиях, странностях setState[3][2].
- **Масштабируемость и удобство поддержки**: код становится чище, логику проще тестировать и документировать.
- **Фокус на функциональном стиле**: в функциональных компонентах вся логика внутри функций, что упрощает композицию.
- **Поддержка будущих возможностей React**: все новые фичи (например, server components) и лучшие практики разрабатываются с расчетом на Hooks[1][3].

## Советы на собеседовании

**Кратко объясняйте:**

- Hooks разрешают использовать state, эффекты, context и другие возможности React в функциональных компонентах.
- Они делают код чище, короче, более реиспользуемым и легче к поддержке.
- Классы поддерживаются ради совместимости, но современный React-разработчик должен уметь работать с Hooks — это индустриальный стандарт.

**Для глубокого ответа:** расскажите о custom hooks, композиции, современном workflow (TypeScript, Suspense, useTransition и т.д.).

**Вывод:**  
Hooks — сердце современной разработки на React. Они делают код проще, чище, позволяют реализовывать современные паттерны и значительно улучшают опыт разработки по сравнению с классами[1][3][2].

</details>
<details>
  <summary>Расскажите про useState, useEffect, useContext и их практическое применение[2][3]</summary>

# React Hooks: useState, useEffect, useContext и их практическое применение

Давайте коротко и по существу: эти три хука — основа любой современной работы с React. Рассмотрим, что делает каждый и как их использовать на практике.

## 1. **useState**

### Что такое

Позволяет добавлять состояние (state) в функциональный компонент.

### Синтаксис

```js
import { useState } from "react";

const [value, setValue] = useState(initialValue);
```

- `value`: текущее значение состояния.
- `setValue`: функция для обновления состояния.
- `initialValue`: начальное значение (любого типа: число, строка, объект, массив).

### Практические примеры

**a. Управление числовым состоянием (счетчик):**

```js
const [count, setCount] = useState(0);

<button onClick={() => setCount(count + 1)}>{count}</button>;
```

**b. Управление состоянием формы:**

```js
const [username, setUsername] = useState("");
<input value={username} onChange={(e) => setUsername(e.target.value)} />;
```

**c. Сложное состояние — объект:**

```js
const [profile, setProfile] = useState({ name: "", age: 0 });
setProfile((prev) => ({ ...prev, name: "Alice" }));
```

## 2. **useEffect**

### Что такое

Позволяет выполнять **побочные эффекты** (side effects) в компонентах: запросы к API, подписки, манипуляции с DOM и т.д.

### Синтаксис

```js
import { useEffect } from "react";

useEffect(() => {
  // side-effect logic (например, fetch, подписка)
  return () => {
    // cleanup logic (при размонтировании или перед повторным выполнением)
  };
}, [deps]);
```

- Основная функция выполняется после первого рендера и **каждого изменения зависимостей** в массиве `deps`.
- Возвращаемая функция внутри useEffect — это cleanup (очистка), вызовется при демонтировании или изменении deps.

### Практические примеры

**a. Получение данных с сервера:**

```js
useEffect(() => {
  fetch("/api/user")
    .then((r) => r.json())
    .then((data) => setUser(data));
}, []); // [] — только при монтировании
```

**b. Подписка на события и очистка:**

```js
useEffect(() => {
  const onResize = () => setWidth(window.innerWidth);
  window.addEventListener("resize", onResize);
  return () => window.removeEventListener("resize", onResize);
}, []);
```

**c. Запуск эффекта при изменении props или state:**

```js
useEffect(() => {
  // этот код выполнится после каждого изменения searchTerm
  fetch(`/api/search?q=${searchTerm}`);
}, [searchTerm]);
```

## 3. **useContext**

### Что такое

Позволяет получать доступ к **глобальным данным** из любого уровня вложенности компонента — решает проблему prop drilling, когда одни и те же данные приходится прокидывать через несколько уровней компонентов.

### Синтаксис

```js
import { useContext } from "react";

const value = useContext(MyContext);
```

- `MyContext` создаётся через `React.createContext()` и оборачивается в провайдер (`<MyContext.Provider value={...}>`).

### Практические примеры

**a. Theme Context (переключение темы):**

```js
const ThemeContext = React.createContext();

function ThemeProvider({ children }) {
  const [theme, setTheme] = useState("light");
  const toggle = () => setTheme((t) => (t === "light" ? "dark" : "light"));
  return (
    <ThemeContext.Provider value={{ theme, toggle }}>
      {children}
    </ThemeContext.Provider>
  );
}

function ThemedButton() {
  const { theme, toggle } = useContext(ThemeContext);
  return (
    <button
      style={{ background: theme === "dark" ? "#333" : "#fff" }}
      onClick={toggle}
    >
      Toggle theme
    </button>
  );
}
```

**b. User Context:**

```js
const UserContext = React.createContext();

function Profile() {
  const user = useContext(UserContext);
  return <div>{user?.name}</div>;
}
```

**Практические best practices**:

- Используйте context для действительно глобальных данных (тема, авторизация, язык и т.п.)
- Не злоупотребляйте context для локального состояния.
  [1][2][3]

## Краткие выводы

- **useState** — позволяет делать интерактивные формы, счетчики, динамические UI.
- **useEffect** — подключает сайд-эффекты и реагирует на изменения данных/props.
- **useContext** — делится глобальными данными прямо между компонентами любой вложенности.

Современный React невозможно представить без этих хуков — ими пользуются практически во всех продакшн-проектах. Умение применять их — ключ к гибкому, масштабируемому и чистому коду!

</details>
<details>
  <summary>Что такое useCallback, useMemo и React.memo? Когда их использовать?</summary>
  # Что такое useCallback, useMemo и React.memo? Когда их использовать?

Эти инструменты служат для **оптимизации производительности** в React-приложениях, помогая избежать ненужных рендеров и затратных вычислений. Давайте разберём, как они работают и когда их действительно стоит применять.

## 1. **useCallback**

**useCallback** — хук, который возвращает "мемоизированную" (кэшированную) версию функции, которая будет сохранять одну и ту же ссылку между рендерами, если не изменились значения в массиве зависимостей.

**Когда использовать:**

- Когда функция передаётся как prop в дочерний компонент, особенно если этот компонент обёрнут в `React.memo`.
- Когда функция используется как зависимость в другом хуке (например, в useEffect или useMemo).
- Для предотвращения ненужных ререндеров дочернего компонента, который зависит от ссылочной идентичности функции[1][2][3].

**Пример:**

```js
const handleClick = useCallback(() => {
  setCount(count + 1);
}, [count]);

<MyButton onClick={handleClick} />;
```

## 2. **useMemo**

**useMemo** — хук, который вычисляет и запоминает результат функции. В отличие от useCallback, useMemo кэширует именно результат (например, объект, массив или результат сложных вычислений), а не саму функцию.

**Когда использовать:**

- Для кэширования затратных вычислений (например, сортировка большого массива, фильтрация, рендер длинных списков).
- Для создания объектов или массивов, которые выступают зависимостями в других хуках или пропсах дочерних компонентов[4][5][6][7].

**Пример:**

```js
const filteredList = useMemo(() => {
  return list.filter((item) => item.active);
}, [list]);
```

## 3. **React.memo**

**React.memo** — HOC (Higher Order Component), который кэширует (мемоизирует) результат рендера функционального компонента. Если пропсы не изменились по ссылке (`===`), React пропустит повторный рендер компонента.

**Когда использовать:**

- Для функциональных компонентов, которые получают пропсы и часто могут получать те же значения пропсов между рендерами (например, элементы списков).
- Когда дочерний компонент тяжёлый или содержит большие поддеревья и рерисовывается слишком часто лишь потому, что родитель обновляется.

**Пример:**

```js
const MyButton = React.memo(function MyButton({ onClick, label }) {
  // ...рендер
});
```

## Сценарии применения и best practices

- Не стоит использовать эти инструменты "везде" — это преждевременная оптимизация, которая может только усложнить код и ухудшить производительность из-за избыточных кешей[8][9][10].
- Используйте `useMemo` и `useCallback`, если:
  - вычисления действительно ресурсоёмкие, либо функция/значение передаются глубоко по дереву пропсов и есть реальные проблемы с производительностью;
  - дочерний компонент или хук реально выигрывает от их применения (например, есть лишние ререндеры).
- Используйте `React.memo`, если компонент получает простые/примитивные пропсы, которые не меняются часто и не передаются как новые объекты/функции на каждое обновление[3][11].

## Краткое сравнение

| Инструмент    | Что кэширует         | Когда нужен                                                                         |
| ------------- | -------------------- | ----------------------------------------------------------------------------------- |
| `useCallback` | Ссылку на функцию    | Когда функция передаётся дочернему компоненту или используется как зависимость хука |
| `useMemo`     | Результат вычисления | Когда есть затратные вычисления или создаётся сложный объект/массив                 |
| `React.memo`  | Сам компонент        | Когда компонент рендерится с одними и теми же пропсами часто                        |

**Вывод:**  
useCallback, useMemo и React.memo нужны для точечной, осознанной оптимизации: они полезны, если в проекте реально есть проблема лишних ререндеров или дорогих вычислений. Без внимания к производительности, их избыточное применение может сделать только хуже. Всегда профилируйте приложение и анализируйте настоящие bottlenecks, прежде чем внедрять подобные оптимизации[2][6][3].

</details>
<details>
  <summary>Как создать кастомный хук? Приведите пример</summary>
  # Как создать кастомный хук в React? Пример и объяснение

**Кастомный хук** (custom hook) — это функция, название которой всегда начинается с `use`, и внутри которой можно использовать любые стандартные хуки (`useState`, `useEffect`, `useContext` и др.). Кастомные хуки позволяют переиспользовать логику между разными компонентами, не плодя HOC и render-props структуры[1][2][3][4].

## Как создать кастомный хук

**Алгоритм:**

1. Назовите функцию по шаблону `useWhatItDoes`.
2. Используйте внутри любые стандартные хуки.
3. Возвращайте любые значения, необходимые компонентам: данные, методы, объекты и т.п.
4. Используйте этот хук в компонентах так же, как стандартные (`useState`, `useEffect`, ...).

### Простой пример 1: useToggle

```javascript
import { useState } from "react";

// Хук для переключения булевого состояния
function useToggle(initialValue = false) {
  const [state, setState] = useState(initialValue);
  const toggle = () => setState((prev) => !prev);
  return [state, toggle];
}

export default useToggle;
```

#### Использование:

```javascript
function Demo() {
  const [isOpen, toggleOpen] = useToggle(false);

  return (
    <div>
      <button onClick={toggleOpen}>{isOpen ? "Скрыть" : "Показать"}</button>
      {isOpen && <p>Отображаемый текст</p>}
    </div>
  );
}
```

### Пример 2: useFetch — универсальный хук для запроса данных

```javascript
import { useState, useEffect } from "react";

function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    let ignore = false;
    setLoading(true);
    setError(null);

    fetch(url)
      .then((res) => {
        if (!res.ok) throw new Error("Ошибка загрузки");
        return res.json();
      })
      .then((json) => {
        if (!ignore) setData(json);
      })
      .catch((err) => {
        if (!ignore) setError(err);
      })
      .finally(() => {
        if (!ignore) setLoading(false);
      });

    return () => {
      ignore = true;
    };
  }, [url]);

  return { data, loading, error };
}

export default useFetch;
```

#### Использование:

```javascript
function Todos() {
  const { data, loading, error } = useFetch(
    "https://jsonplaceholder.typicode.com/todos"
  );

  if (loading) return <p>Загрузка...</p>;
  if (error) return <p>Ошибка: {error.message}</p>;

  return (
    <ul>
      {data.map((todo) => (
        <li key={todo.id}>{todo.title}</li>
      ))}
    </ul>
  );
}
```

## Лучшие практики для кастомных хуков

- **Имя всегда с `use`**: чтобы React мог валидировать правила хуков.
- **Одна ответственность**: каждый кастомный хук отвечает за одну конкретную задачу — данные, форму, подписку и т.д.[5].
- **Можно использовать другие хуки**: внутри кастомного можно вызывать любые стандартные или другие пользовательские хуки.
- **Не возвращайте лишнего**: возвращайте компоненту только нужные данные, без избыточности.
- **Документируйте кастомные хуки**: особенно если ими будет пользоваться команда.

## Вывод

Кастомные хуки — мощнейший инструмент масштабируемого React-кода. Вынесите повторяющуюся бизнес-логику в хук, и ваш проект станет легче поддерживать, тестировать и расширять.

</details>
<details>
  <summary>Объясните правила хуков и почему их важно соблюдать</summary>

**React Hooks** — мощный инструмент, но работают они корректно только при соблюдении строгих правил. Эти правила обеспечивают предсказуемое поведение приложения и предотвращают сложные ошибки.

## Основные правила хуков

### 1. **Вызывайте хуки только на верхнем уровне компонента**

- **Нельзя** вызывать хуки внутри циклов, условий (`if`/`switch`), вложенных функций или после ранних `return`[1][2][3][4][5].
- **Почему:** React опирается на порядок вызова хуков для корректного сопоставления состояния и эффектов между рендерами. Если нарушить последовательность вызовов (например, вызвать хук только при определенном условии), React «собьется» и начнет подставлять не те значения, что приведет к трудноуловимым багам.

> **Пример неверно:**
>
> ```js
> if (show) {
>   useEffect(...); // ❌ Нельзя!
> }
> ```

> **Правильно:**
>
> ```js
> useEffect(() => {
>   if (show) {
>     // ...
>   }
> }, [show]);
> ```

### 2. **Вызывайте хуки только внутри React-функций**

- **Можно:** из тела React-функционального компонента или собственного кастомного хука.
- **Нельзя:** просто из обычной JS-функции, метода класса или обработчиков событий вне тела компонента[1][2][3][5].

> **Почему:** Хуки предназначены для работы строго в контексте React-рендера. Это гарантирует, что React корректно отслеживает и сохраняет состояние.

### 3. **Соблюдайте одинаковый порядок вызова хуков на каждом рендере**

- **Нельзя:** вызывать хуки по-разному в зависимости от условий.
- **Почему:** React строит внутренний список хуков и сопоставляет значения по их порядку. Изменится порядок — React начнет подменять значения от одного хука другому, и возникнут баги [1][3][2].

### 4. **Пользовательские хуки должны начинаться с "use"**

- Это негласное правило индустрии. Оно позволяет линтерам автоматически находить потенциальные ошибки, а другим разработчикам — сразу видеть, что это хук [1][2][6].

## Почему правила хуков важны

- **Предсказуемость:** Обеспечивают стабильную работу компонентов между рендерами, даже если рендерятся редко или часто.
- **Борьба с багами:** Защищают от труднопредсказуемых проблем, связанных с потерей состояния, неправильным порядком обновления эффектов/данных и деградацией производительности [1][2][6].
- **Будущая совместимость:** Гарантируют, что код работает и будет работать на новых версиях React без критической переработки [2].
- **Автоматизация:** Позволяют использовать инструменты (например, `eslint-plugin-react-hooks`), автоматически отлавливающие нарушения правил [3][7].

## Практический совет

- **Подключите линтер:** Используйте `eslint-plugin-react-hooks`, чтобы избегать ошибок даже случайно.
- **Вызывайте хуки всегда одинаковым образом** на каждом рендере, только в компонентах или кастомных хуках, вне циклов, условий и вложенных функций.

### Краткий запоминающийся ответ для собеседования

> "Хуки в React должны вызываться только на верхнем уровне функционального компонента или кастомного хука, всегда в одном и том же порядке, и только внутри React-функций. Это необходимо, чтобы React корректно отслеживал состояния и эффекты между рендерами. Нарушение этих правил приводит к трудноотлавливаемым багам и потере контроля над компонентом."

</details>

