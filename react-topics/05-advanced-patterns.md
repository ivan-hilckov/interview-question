# Продвинутые паттерны

HOC, Render Props, Compound Components

---

### Продвинутые паттерны

<details>
  <summary>Объясните паттерны Higher Order Components (HOC) и Render Props.</summary>

Оба эти паттерна — способы **реиспользовать компонентную логику** и убрать дублирование кода в React до появления хуков. У каждого есть свои преимущества, ограничения и особенности.

## 1. **Higher Order Components (HOC)**

### Что это

**HOC** — функция, принимающая компонент и возвращающая новый компонент с дополнительной логикой или пропсами.  
Это внешний способ "подмешать" логику в любой компонент без боли копипаста[1][2][3][4][5].

### Синтаксис

```js
const withUser = (WrappedComponent) => {
  return function EnhancedComponent(props) {
    const [user, setUser] = useState(null);
    useEffect(() => {
      fetchUser().then(setUser);
    }, []);
    return <WrappedComponent {...props} user={user} />;
  };
};
```

Использование:

```js
const UserProfileWithUser = withUser(UserProfile);
```

### Ключевые особенности

- Позволяет отделять логику от отображения (Separation of Concerns)[2][6].
- HOC не изменяет оригинальный компонент — создаётся обёртка.
- Можно комбинировать несколько HOC для сложной логики (compose).

### Пример практического применения

- Подключение к стору (например, connect в Redux).
- Логика авторизации (withAuth).
- Повторное использование побочных эффектов без дублирования кода.

## 2. **Render Props**

### Что это

**Render Props** — это паттерн, когда компонент принимает проп, значение которого является функцией, и вызывает её для описания того, как рендерить часть UI[7][8][9][10][11].

### Синтаксис

```js
function DataFetcher({ render }) {
  const [data, setData] = useState(null);
  useEffect(() => {
    loadData().then(setData);
  }, []);
  return render(data);
}

function App() {
  return (
    <DataFetcher
      render={(data) => <span>{data ? data.name : "Loading..."}</span>}
    />
  );
}
```

Или можно использовать children как функцию:

```js
<DataFetcher>{(data) => <span>{data}</span>}</DataFetcher>
```

### Ключевые особенности

- Dynamic rendering: рендер можно определять “снаружи” (в родителе), а компонент-селлер оставляет за собой только внутреннюю логику[7][9][10][12].
- Позволяет разграничивать логику и отображение, гибко настраивать рендеринг.

### Пример практического применения

- Mouse/Touch tracking: компонент отслеживает координаты мыши и вызывает render с этими данными.
- Дата-фечинг: повторного использования логики загрузки с различными вариантами рендера.

## HOC vs Render Props — сравнение

| Аспект            | HOC                                                                          | Render Props                                             |
| ----------------- | ---------------------------------------------------------------------------- | -------------------------------------------------------- |
| Реализация        | Принимает компонент, возвращает новый компонент                              | Принимает функцию, вызывает для render                   |
| Монтирование      | Повышает дерево: обёртка вокруг оригинального                                | Глубже дерево: одна функция внутри другой                |
| Ясность структуры | Может быть неочевидно, какие пропы “инъецированы”                            | Ясно видно, что передаётся и откуда                      |
| Проблемы          | Сложность с hoist-non-react-statics, prop name clashes (“wrapper hell”)      | Может появиться “callback hell” при глубокой вложенности |
| Use cases         | Логика, которую нужно подмешать во многие компоненты (например, auth, store) | Логика, для которой требуется кастомный рендер           |

## Современный контекст

С появлением хуков (useState, useEffect, custom hooks) оба паттерна реже используются для повторного использования логики — custom хуки стали проще и чище. Однако HOC/Render Props по-прежнему встречаются в сторонних библиотеках (например, styled-components, react-redux, react-router-dom).

## Краткое резюме для собеседования

> “HOC — это функция, возвращающая новый компонент с дополнительной логикой, что удобно для логик вроде подключения к store или авторизации. Render Props — это передача функции для рендера части UI, что гибко и удобно для data fetching, трекинга мыши, анимации и др. Оба паттерна сделали возможным повторное использование логики до появления хуков, но и сейчас встречаются в большом React-коде и библиотеках.”

</details>
<details>
  <summary>Что такое Compound Components и когда их использовать?</summary>
  # Что такое Compound Components и когда их использовать?

**Compound Components** — это паттерн проектирования в React, при котором несколько связанных компонентов работают вместе, деля между собой логику и состояние, чтобы реализовать единую сложную функциональность. Этот подход позволяет пользователю компонента гибко комбинировать дочерние компоненты внутри одного родителя, при этом вся необходимая логика и состояние остаются инкапсулированными в родителе[1][2][3][4][5].

## Суть паттерна

- **Родительский компонент** хранит общее состояние и логику.
- **Дочерние компоненты** получают нужные данные и функции через props, context или React.Children API.
- Использование похоже на разметку `<select> <option/> </select>` в HTML: дочерние компоненты "понимают", в каком контексте они расположены, и как взаимодействовать с родителем.

### Пример из HTML:

```html
<select>
  <option value="js">JavaScript</option>
  <option value="ts">TypeScript</option>
</select>
```

## Пример Compound Components в React

```js
const TabsContext = React.createContext();

function Tabs({ children, initialActive = 0 }) {
  const [active, setActive] = React.useState(initialActive);
  return (
    <TabsContext.Provider value={{ active, setActive }}>
      <div>{children}</div>
    </TabsContext.Provider>
  );
}

function TabList({ children }) {
  return <div className="tab-list">{children}</div>;
}
function Tab({ index, children }) {
  const { active, setActive } = React.useContext(TabsContext);
  return (
    <button
      className={active === index ? "active" : ""}
      onClick={() => setActive(index)}
    >
      {children}
    </button>
  );
}
function TabPanel({ index, children }) {
  const { active } = React.useContext(TabsContext);
  return active === index ? <div>{children}</div> : null;
}

// Использование:
<Tabs>
  <TabList>
    <Tab index={0}>Вкладка 1</Tab>
    <Tab index={1}>Вкладка 2</Tab>
  </TabList>
  <TabPanel index={0}>Контент 1</TabPanel>
  <TabPanel index={1}>Контент 2</TabPanel>
</Tabs>;
```

_Контекст обеспечивает связь между всеми дочерними компонентами, и нет необходимости передавать пропсы вручную на каждый уровень вложенности[2][6]._

## Преимущества Compound Components

- **Гибкость для пользователя:** потребители компонента могут свободно задавать структуру, менять порядок, опускать или дублировать части — компоненты работают “как единое целое”.
- **Внутренняя инкапсуляция:** внутренняя логика и состояние скрыты, работать нужно только с нужными дочерними компонентами[4][7][3][5].
- **Отсутствие prop drilling:** дочерние компоненты получают все необходимые данные автоматически через context/props.
- **Возможность легкого расширения:** можно пополнять семейство дочерних компонентов (например, Tab, TabPanel, TabList) без изменений API родителя.

## Когда использовать Compound Components?

- **При разработке сложных UI-виджетов**: табы, аккордеоны, меню, модальные окна, шаговые интерфейсы (stepper), dropdown-меню и др.[1][4][3].
- **В дизайн-системах и UI-библиотеках**: для достижения максимальной гибкости и выразительности API.
- **Когда разные части компонента тесно связаны логикой, но должны быть разнесены по дереву JSX**.

## Примеры популярных библиотек

- UI-библиотеки (например, ReachUI, Chakra UI, Headless UI) активно используют этот паттерн: `<Menu><MenuButton/><MenuList/><MenuItem/></Menu>`[4].

## Недостатки

- **Сложнее реализовать по сравнению с обычными компонентами** из-за использования контекста, cloneElement или React.Children API.
- **Легкая потеря читаемости** при большой вложенности.
- Новички могут путаться в “магии” передачи состояния через контекст.

## Вывод для собеседования

> “Compound Components — это паттерн, при котором группа связанных компонентов (например, Tabs и Tab/TabPanel) работает вместе, разделяя состояние и логику родителя через контекст. Такой подход даёт гибкий и выразительный API, облегчает повторное использование и расширяемость компонентов. Особенно полезен для построения сложных виджетов и дизайн-систем, когда разные части интерфейса тесно связаны логически.”

</details>
<details>
  <summary>Как работают React Portals и для чего они нужны?</summary>
  # React Portals: как работают и зачем нужны

## Что такое React Portals

**React Portals** — механизм, позволяющий рендерить дочерние компоненты вне основного DOM-дерева их родителя, но логически оставляя их частью того же React-компонентного дерева. Проще говоря: компонент объявлен в одном месте, а отображается в совершенно другом месте DOM — например, вне обычного layout-приложения[1][2][3][4][5].

## Как работают React Portals

- Используют метод `ReactDOM.createPortal(children, container)`
- Первый аргумент — JSX или React-элемент, который нужно отрендерить
- Второй аргумент — DOM-элемент, в который этот JSX будет “помещён” (container должен находиться вне обычного DOM-потока приложения — например, в `<div id="modal-root"></div>` в index.html)
- Компонент, отрисованный через Portal, наследует все props, контекст и события от родителя, даже если находится вне его визуального DOM-потока[3][4][6][7]

### Пример использования

**Добавьте в public/index.html:**

```html
<body>
  <div id="root"></div>
  <div id="modal-root"></div>
</body>
```

**React-компонент:**

```javascript
import ReactDOM from "react-dom";

const Modal = ({ children }) => {
  return ReactDOM.createPortal(
    <div className="modal">{children}</div>,
    document.getElementById("modal-root")
  );
};
```

**Использование:**

```javascript
// Внутри любого компонента
<Modal>
  <h1>Всплывающее окно</h1>
</Modal>
```

## Практические сценарии применения

**Portals особенно полезны для:**

- **Модальных окон (modals, dialogs, popups)** — контент должен перекрывать всё остальное приложение и не "заломаться" стилями родителя[2][3][8][9]
- **Tooltip'ов и popover'ов** — позиции могут выходить за границы layout и нужны поверх других элементов
- **Dropdown-меню, overlay, toaster'ов** (уведомления)
- **Drag & Drop** — когда переносимый элемент должен отображаться над всем содержимым, независимо от вложенности

## Преимущества использования Portals

- **Изоляция от DOM-контекста**: элемент не зависит от родительских overflow, z-index, стилизации и ограничений
- **Чистота архитектуры**: UI-логику можно реализовать в одном месте, но отображение контролировать централизованно[5][9]
- **Доступность и управление фокусом**: модальные окна становятся доступными для скринридеров и систем навигации
- **Снижение "CSS-конфликтов"**: overlay и pop-up не будут ломаться стилями родителя

## Краткий ответ для собеседования

> React Portals позволяют рендерить компоненты вне текущей DOM-иерархии, сохраняя их связь с React-деревом. Обычно я применяю порталы для модальных окон, плашек-уведомлений, тултипов — то есть для любого UI, который должен “выходить за пределы” контейнера. Это помогает избежать проблем со слоями (z-index, overflow), а также поддерживать чистую и гибкую архитектуру интерфейса.

</details>
<details>
  <summary>Что такое React Fragments и зачем они нужны?</summary>
  # Что такое React Fragments и зачем они нужны?

**React Fragments** — это специальный механизм в React, позволяющий группировать несколько JSX-элементов без добавления лишнего узла в DOM. Благодаря им можно возвращать из компонента сразу несколько элементов, не засоряя DOM-дерево ненужными контейнерами (`<div>` и др.)[1][2][3][4][5].

## Ключевые особенности Fragments

1. **Нет лишних DOM-элементов**

   - Обычно, если вы возвращаете в React несколько элементов, нужно было оборачивать их в `<div>`, что осложняло структуру DOM и вызывало проблемы с вёрсткой (flex, grid, списки, HTML-валидность).
   - Fragment не добавляет в DOM ничего — в инспекторе браузера вы увидите только те элементы, которые должны быть на странице[1][2][6][3][7].

2. **Чистота и производительность**
   - Меньше "wrapper-ов" — быстрее рендеринг, меньше память, проще селекторы и манипуляции через JS или CSS[3][4][8].
   - Нет "лишних" родителей, которые ломали бы стили (flex, grid может работать некорректно, если вложена ещё одна обёртка)[8][7].

## Примеры использования

### Простой пример:

```jsx
return (
  <>
    <h1>Заголовок</h1>
    <p>Абзац текста</p>
  </>
);
```

или эквивалентно:

```jsx
import { Fragment } from "react";

return (
  <Fragment>
    <h1>Заголовок</h1>
    <p>Абзац текста</p>
  </Fragment>
);
```

- Такой код возвращает оба элемента, но не создает лишних обёрток в DOM-дереве[2][3].

### В списках:

Если нужно вернуть несколько элементов в map (например, для таблицы):

```jsx
{
  rows.map((row) => (
    <React.Fragment key={row.id}>
      <td>{row.name}</td>
      <td>{row.value}</td>
    </React.Fragment>
  ));
}
```

- Только `React.Fragment`, а не shorthand `<>`, позволяет задавать key — это важно для списков[6][3].

## Когда FRAGMENTS особенно полезны?

- При создании **таблиц** (`<tr>` с несколькими `<td>`), где `div` может сделать HTML невалидным.
- Для оптимизации DOM при больших/глубоких компонентах, чтобы избежать “Div Soup” (захламления лишними обертками).
- Если нужно возвращать из компонента несколько элементов, но **нет смысла или нельзя** использовать дополнительный контейнер для организации вёрстки[4][8].

## Отличие от `<div>`

|                         | **React Fragment** | **div**                  |
| ----------------------- | ------------------ | ------------------------ |
| DOM                     | Не добавляет узел  | Добавляет `<div>`        |
| Атрибуты                | Только `key`       | Любые атрибуты           |
| CSS/стили               | Нет класса/стиля   | Можно передать стили     |
| Использование в списках | Да (`key`)         | Да                       |
| Семантика               | Не влияет          | Может нарушить структуру |

## Краткий вывод для собеседования

> "React Fragments позволяют возвращать несколько элементов из компонента без добавления лишних узлов в DOM. Это оптимизирует структуру HTML, ускоряет работу браузера и помогает избегать проблем с некорректной вёрсткой, которые возникали из-за ненужных обёрток вроде `<div>`. Я использую Fragments, когда нужно сгруппировать JSX-элементы там, где дополнительный контейнер не нужен или даже вреден."

</details>